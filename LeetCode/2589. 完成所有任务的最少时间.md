## 2589. 完成所有任务的最少时间

你有一台电脑，它可以 同时 运行无数个任务。给你一个二维整数数组 tasks ，其中 tasks[i] = [starti, endi, durationi] 表示第 i 个任务需要在 闭区间 时间段 [starti, endi] 内运行 durationi 个整数时间点（但不需要连续）。

当电脑需要运行任务时，你可以打开电脑，如果空闲时，你可以将电脑关闭。

请你返回完成所有任务的情况下，电脑最少需要运行多少秒。

 

示例 1：

>输入：tasks = \[[2,3,1],[4,5,1],[1,5,2]]  
>输出：2  
>解释：  
>- 第一个任务在闭区间 [2, 2] 运行。  
>- 第二个任务在闭区间 [5, 5] 运行。  
>- 第三个任务在闭区间 [2, 2] 和 [5, 5] 运行。  
>电脑总共运行 2 个整数时间点。  


示例 2：

>输入：tasks = \[[1,3,2],[2,5,3],[5,6,2]]  
>输出：4  
>解释：  
>- 第一个任务在闭区间 [2, 3] 运行  
>- 第二个任务在闭区间 [2, 3] 和 [5, 5] 运行。  
>- 第三个任务在闭区间 [5, 6] 运行。  
>电脑总共运行 4 个整数时间点。  
 

提示：

- 1 <= tasks.length <= 2000
- tasks[i].length == 3
- 1 <= starti, endi <= 2000
- 1 <= durationi <= endi - starti + 1 



## 题解

### 解法一、贪心

```java
class Solution {
    // 将任务按结束时间从小到大排序，右边的任务要么与当前任务有交集，要么没有交集
    // 用数组记录运行的时间点
    // 枚举每一个任务,统计当前任务区间上以运行的时间点数目，若还有时间未用完，从结束位置开始标记未运行的时间点为已运行的时间点
    public int findMinimumTime(int[][] tasks) {
        Arrays.sort(tasks, (a, b) -> a[1] - b[1]);
        int[] run = new int[2001];
        int ans = 0;
        for (int[] task: tasks) {
            int start = task[0], end = task[1], d = task[2];
            for (int i = end; i >= start; i--) {
                d -= run[i];
            }
            for (int i = end; i >= start && d > 0; i--) {
                if (run[i] == 1) continue;
                run[i]++;
                d--;
                ans++;
            }
        }
        return ans;
    }
}
```


### 解法二、线段树优化

```java
class Solution {
    public int findMinimumTime(int[][] tasks) {
        Arrays.sort(tasks, (a, b) -> a[1] - b[1]);
        int n = tasks[tasks.length - 1][1];
        SegmentTree tree = new SegmentTree(n);
        for (int[] task: tasks) {
            int start = task[0], end = task[1], d = task[2];
            int suffix = d - tree.query(start, end);
            tree.update(start, end, suffix);
        }
        return tree.query(1, n);
    }

    static class SegmentTree {
        private int[] cnt;
        private boolean[] todo;
        private int suffix;
        private int n;

        public SegmentTree(int n) {
            cnt = new int[n * 4];
            todo = new boolean[n * 4];
            suffix = 0;
            this.n = n;
        }

        // 查询区间[L, R]运行的时间点总数
        public int query(int L, int R) {
            return query(1, 1, n, L, R);
        }

        public int query(int node, int l, int r, int L, int R) {
            if (L <= l && r <= R) return cnt[node];
            int m = (l + r) >> 1;
            int left = node * 2;
            int right = node * 2 + 1;
            spread(node, l, m, r);
            if (m >= R) return query(left, l, m, L, R);
            if (m < L) return query(right, m + 1, r, L, R);
            return query(left, l, m, L, R) + query(right, m + 1, r, L, R);
        }

        // 将区间[L, R]的最右边suffix非工作状态的时间点标记位工作状态
        public void update(int L, int R, int suffix) {
            this.suffix = suffix;
            update(1, 1, n, L, R);
        }

        public void update(int node, int l, int r, int L, int R) {
            int size = r - l + 1;
            if (cnt[node] == size) return;
            if (L <= l && r <= R && size - cnt[node] <= suffix) {
                suffix -= size - cnt[node];
                do_(node, l, r);
                return;
            }
            int m = (l + r) >> 1;
            int left = node * 2;
            int right = node * 2 + 1;
            spread(node, l, m, r);
            if (m < R) update(right, m + 1, r, L, R);
            if (suffix > 0) update(left, l, m, L, R);
            cnt[node] = cnt[left] + cnt[right];
        }

        private void do_(int node, int l, int r) {
            cnt[node] = r - l + 1;
            todo[node] = true;
        }

        private void spread(int node, int l, int m, int r) {
            if (todo[node]) {
                do_(node * 2, l, m);
                do_(node * 2 + 1, m + 1, r);
                todo[node] = false;
            }
        }
    }
}
```
