## 149. 直线上最多的点数

给你一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点。求最多有多少个点在同一条直线上。

 

示例 1：


>输入：points = \[[1,1],[2,2],[3,3]]  
>输出：3  


示例 2：


>输入：points = \[[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]  
>输出：4  
 

提示：

- 1 <= points.length <= 300
- points[i].length == 2
- -$10^4$ <= xi, yi <= $10^4$
- points 中的所有点 互不相同

## 题解

### 解法一、

```java
class Solution {
    // 朴素方法：枚举每一个斜率以及斜率不存在的点的组合，计算该斜率上点的数目
    // O(n^3)
    // 第二种方法
    // 枚举经过给定点的直线最多有多少个点在该直线上
    // 优化：
    // 1. 在枚举点i时，点i与左边的点的斜率已经被考虑过，考虑右边的点即可
    // 2. 在枚举点i时，至多有n-i个点在经过点i的直线上
    // 3. 当经过某个点的直线有一半的点在直线上时，该结果为最优解
    public int maxPoints(int[][] points) {
        int n = points.length;
        if (n <= 2) return n;
        int ans = 1;
        for (int i = 0; i < n; i++) {
            if (ans > n / 2) return ans;
            Map<Integer, Integer> map = new HashMap<>();
            for (int j = i + 1; j < n; j++) {
                int k = slope(points[i], points[j]);
                map.put(k, map.getOrDefault(k, 0) + 1);
                ans = Math.max(ans, map.get(k) + 1);
            }
        }
        return ans;
    }

    int gcd(int a, int b) {
        return b == 0? a: gcd(b, a % b);
    }

    int slope(int[] x, int[] y) {
        int dx = y[0] - x[0], dy = y[1] - x[1];
        if (dx == 0) return 1;
        if (dy == 0) return 200_001;
        int m = gcd(dx, dy);
        dx /= m;
        dy /= m;
        if (dx < 0) {
            dx = -dx;
            dy = -dy;
        }
        return dy + 200_001 * dx;
    }
}
```