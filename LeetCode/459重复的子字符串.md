## 459. 重复的子字符串

给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。

 

示例 1:

>输入: s = "abab"  
>输出: true  
>解释: 可由子串 "ab" 重复两次构成。  

示例 2:

>输入: s = "aba"  
>输出: false  

示例 3:

>输入: s = "abcabcabcabc"  
>输出: true  
>解释: 可由子串 "abc" 重复四次构成。 (或子串 "abcabc" 重复两次构成。)  
 

提示：

- 1 <= s.length <= $10^4$
- s 由小写英文字母组成

## 题解

### 解法一、KMP算法+移动匹配

```java
class Solution {

    int[] getNext(String pattern) {
        int m = pattern.length();
        char[] s = pattern.toCharArray();
        int[] next = new int[m];
        // [0, j)定义一个最长前缀
        int j = 0;
        // (i - j, i]定义一个最长后缀
        for (int i = 1; i < m; i++) {
            // 每次匹配过程相当于在上一次最长前后缀的基础上再做一次字符串匹配
            // 如果不匹配则回退，直到匹配或不能回退
            while (j > 0 && s[i] != s[j]) {
                j = next[j - 1];
            }
            // 如果匹配则最长前缀加1
            if (s[i] == s[j]) j++;
            next[i] = j;
        }
        return next;
    }

    public boolean repeatedSubstringPattern(String s) {
        // 移动匹配
        // 如果字符串s是由某个子串sub多次重复构成的，则s + s内部一定包含一个s的子字符串
        // 可以证明，这是一个充要条件
        String str = s + s;
        int n = s.length() << 1;
        int[] next = getNext(s);
        // [0, j)已匹配模式串
        int j = 0;
        // (i - j, i]已匹配文本串
        for (int i = 1; i < n - 1; i++) {
            while (j > 0 && str.charAt(i) != s.charAt(j)) {
                j = next[j - 1];
            }
            if (str.charAt(i) == s.charAt(j)) j++;
            if (j == s.length()) return true;
        }
        return false;
    }
}
```
