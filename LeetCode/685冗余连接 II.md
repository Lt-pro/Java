## 685. 冗余连接 II

在本问题中，有根树指满足以下条件的 有向 图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。

输入一个有向图，该图由一个有着 n 个节点（节点值不重复，从 1 到 n）的树及一条附加的有向边构成。附加的边包含在 1 到 n 中的两个不同顶点间，这条附加的边不属于树中已存在的边。

结果图是一个以边组成的二维数组 edges 。 每个元素是一对 [ui, vi]，用以表示 有向 图中连接顶点 ui 和顶点 vi 的边，其中 ui 是 vi 的一个父节点。

返回一条能删除的边，使得剩下的图是有 n 个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。

 

示例 1：

![g1](./figs/graph1.jpg)

>输入：edges = \[[1,2],[1,3],[2,3]]  
>输出：[2,3]  


示例 2：

![g2](./figs/graph2.jpg)

>输入：edges = \[[1,2],[2,3],[3,4],[4,1],[1,5]]  
>输出：[4,1]  
 

提示：

- n == edges.length
- 3 <= n <= 1000
- edges[i].length == 2
- 1 <= ui, vi <= n

## 题解

### 解法一、并查集

```java
class Solution {
    public int[] findRedundantDirectedConnection(int[][] edges) {
        int n = edges.length;
        int[] inDegree = new int[n + 1];
        for (int[] edge: edges) inDegree[edge[1]]++;
        List<Integer> list = new ArrayList<>();
        for (int i = n - 1; i >= 0; i--) {
            if (inDegree[edges[i][1]] == 2) {
                list.add(i);
            }
        }

        if (!list.isEmpty()) {
            if (isTreeAfterRemoveEdge(edges, list.get(0))) {
                return edges[list.get(0)];
            } else {
                return edges[list.get(1)];
            }
        }
        return getRemoveEdge(edges);
    }

    int[] getRemoveEdge(int[][] edges) {
        DisjointSetUnion dsu = new DisjointSetUnion(edges.length + 1);
        for (int[] edge: edges) {
            int u = dsu.find(edge[0]);
            int v = dsu.find(edge[1]);
            if (u == v) {
                return edge;
            }
            dsu.union(edge[0], edge[1]);
        }
        return new int[]{};
    }

    boolean isTreeAfterRemoveEdge(int[][] edges, int deleteEdge) {
        DisjointSetUnion dsu = new DisjointSetUnion(edges.length + 1);
        for (int i = 0; i < edges.length; i++) {
            if (i == deleteEdge) continue;
            int[] edge = edges[i];
            int u = dsu.find(edge[0]);
            int v = dsu.find(edge[1]);
            if (u == v) {
                return false;
            }
            dsu.union(edge[0], edge[1]);
        }
        return true;
    }

    static class DisjointSetUnion {
        private int[] parents;

        public DisjointSetUnion(int n) {
            parents = new int[n];
            Arrays.fill(parents, -1);
        }

        public int find(int u) {
            return parents[u] < 0? u: (parents[u] = find(parents[u]));
        }

        public void union(int u, int v) {
            int fu = find(u);
            int fv = find(v);
            if (fu == fv) return;
            parents[fv] = fu;
        }
    }
}
```


## 相关问题

- [684. 冗余连接](./684冗余连接.md)
- [685. 冗余连接 II](./685冗余连接%20II.md)
