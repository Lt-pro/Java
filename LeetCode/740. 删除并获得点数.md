## 740. 删除并获得点数

给你一个整数数组 nums ，你可以对它进行一些操作。

每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。

开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。

 

示例 1：

>输入：nums = [3,4,2]  
>输出：6  
>解释：  
>删除 4 获得 4 个点数，因此 3 也被删除。  
>之后，删除 2 获得 2 个点数。总共获得 6 个点数。  


示例 2：

>输入：nums = [2,2,3,3,3,4]  
>输出：9  
>解释：  
>删除 3 获得 3 个点数，接着要删除两个 2 和 4 。  
>之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。  
>总共获得 9 个点数。  
 

提示：

- 1 <= nums.length <= 2 * 104
- 1 <= nums[i] <= 104


## 题解

### 解法一、dp

```java
class Solution {
    public int deleteAndEarn(int[] nums) {
        // 打家劫舍变体
        // 选择元素nums[i]后，所有nums[i] - 1, nums[i] + 1的元素全部被删除，
        // 若还有值为nums[i]的元素, 则不会再删除任何元素，故删除元素nums[i]获得的点数是所有值为nums[i]的和
        // 统计所有元素对应的点数，则操作规则变为选择nums[i]的点数，则不能获取相邻元素的点数，等效为打家劫舍问题
        int m = 0;
        for (int val: nums) m = Math.max(m, val);
        int[] dp = new int[m + 1];
        for (int val: nums) dp[val] += val;
        for (int i = 2; i <= m; i++) {
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + dp[i]);
        }
        return dp[m];
    }
}
```


## 相关问题

- [198. 打家劫舍](./198.%20打家劫舍.md)
- [213. 打家劫舍 II](./213.%20打家劫舍%20II.md)
- [337. 打家劫舍 III](./337.%20打家劫舍%20III.md)
- [740. 删除并获得点数](./740.%20删除并获得点数.md)