## 51. N 皇后

按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。  

n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。  

给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。  

每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。  

示例 1：  

![N皇后](./figs/queens.jpg)

>输入：n = 4  
>输出：\[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]  
>解释：如上图所示，4 皇后问题存在两个不同的解法。  


示例 2：  

>输入：n = 1  
>输出：\[["Q"]]  
 

提示：  

- 1 <= n <= 9

## 题解

### 方法一、回溯

```java
class Solution {
    private List<List<String>> result = new ArrayList<List<String>>();

    static List<String> generate(int[] queens) {
        int n = queens.length;
        List<String> answer = new ArrayList<String>();
        for (int i = 0; i < n; i++) {
            char[] s = new char[n];
            Arrays.fill(s, '.');
            s[queens[i]] = 'Q';
            answer.add(new String(s, 0, n));
        }
        return answer;
    }

    public void dfs(int[] queens, int i, Set<Integer> columns, Set<Integer> diagnals1, Set<Integer> diagnals2) {
        if (i >= queens.length) {
            result.add(generate(queens));
            return;
        }
        for (int j = 0; j < queens.length; j++) {
            // O(1)判断是否在同一列、同一斜线
            if (columns.contains(j)) continue;
            int delta1 = j - i;     // 直线上的点有相同的截距
            if (diagnals1.contains(delta1)) continue;
            int delta2 = j + i;     // 直线上的点有相同的截距
            if (diagnals2.contains(delta2)) continue;

            columns.add(j);
            diagnals1.add(delta1);
            diagnals2.add(delta2);
            queens[i] = j;
            dfs(queens, i + 1, columns, diagnals1, diagnals2);
            queens[i] = 0;
            diagnals2.remove(delta2);
            diagnals1.remove(delta1);
            columns.remove(j);
        }
    }

    public List<List<String>> solveNQueens(int n) {
        dfs(new int[n], 0, new HashSet<Integer>(), new HashSet<Integer>(), new HashSet<Integer>());
        return result;
    }
}
```

### 方法二、位运算优化

```java
class Solution {
    private List<List<String>> result = new ArrayList<List<String>>();

    static List<String> generate(int[] queens) {
        int n = queens.length;
        List<String> answer = new ArrayList<String>();
        for (int i = 0; i < n; i++) {
            char[] s = new char[n];
            Arrays.fill(s, '.');
            s[queens[i]] = 'Q';
            answer.add(new String(s, 0, n));
        }
        return answer;
    }

    public void dfs(int[] queens, int i, int columns, int diagnals1, int diagnals2) {
        if (i >= queens.length) {
            result.add(generate(queens));
            return;
        }
        int pivot = columns | diagnals1 | diagnals2;
        for (int j = 0; j < queens.length; j++) {
            boolean valid = (pivot & 1) == 1;
            pivot >>>= 1;
            if (valid) continue;
            queens[i] = j;
            int delta = 1<<j;
            // 下一次访问不能选择的位置
            dfs(queens, i + 1, columns + delta, (diagnals1 + delta)<<1, (diagnals2 + delta)>>1);
            queens[i] = 0;
        }
    }

    public List<List<String>> solveNQueens(int n) {
        dfs(new int[n], 0, 0, 0, 0);
        return result;
    }
}
```