## 2967. 使数组成为等数数组的最小代价

给你一个长度为 n 下标从 0 开始的整数数组 nums 。

你可以对 nums 执行特殊操作 任意次 （也可以 0 次）。每一次特殊操作中，你需要 按顺序 执行以下步骤：

从范围 [0, n - 1] 里选择一个下标 i 和一个 正 整数 x 。
将 |nums[i] - x| 添加到总代价里。
将 nums[i] 变为 x 。
如果一个正整数正着读和反着读都相同，那么我们称这个数是 回文数 。比方说，121 ，2552 和 65756 都是回文数，但是 24 ，46 ，235 都不是回文数。

如果一个数组中的所有元素都等于一个整数 y ，且 y 是一个小于 109 的 回文数 ，那么我们称这个数组是一个 等数数组 。

请你返回一个整数，表示执行任意次特殊操作后使 nums 成为 等数数组 的 最小 总代价。

 

示例 1：

> 输入：nums = [1,2,3,4,5]  
> 输出：6  
> 解释：我们可以将数组中所有元素变为回文数 3 得到等数数组，数组变成 [3,3,3,3,3] 需要执行 4 次特殊操作，代价为 |1 - 3| + |2 - 3| + |4 - 3| + |5 - 3| = 6 。  
> 将所有元素变为其他回文数的总代价都大于 6 。  

示例 2：

> 输入：nums = [10,12,13,14,15]  
> 输出：11  
> 解释：我们可以将数组中所有元素变为回文数 11 得到等数数组，数组变成 [11,11,11,11,11] 需要执行 5 次特殊操作，代价为 |10 - 11| + |12 - 11| + |13- 11| + |14 - 11| + |15 - 11| = 11 。  
>将所有元素变为其他回文数的总代价都大于 11 。  

示例 3 ：

> 输入：nums = [22,33,22,33,22]  
> 输出：22  
> 解释：我们可以将数组中所有元素变为回文数 22 得到等数数组，数组变为 [22,22,22,22,22] 需要执行 2 次特殊操作，代价为 |33 - 22| + |33 - 22| = 22 。  
>将所有元素变为其他回文数的总代价都大于 22 。  
 

提示：

- 1 <= n <= $10^5$
- 1 <= nums[i] <= $10^9$


## 题解

### 解法一、

```java
class Solution {
    // 参考自：灵茶山艾府
    private static final int[] pal = new int[109999];

    static {
        int palIdx = 0;
        for (int base = 1; base <= 10000; base *= 10) {
            // 生成奇数长度回文数
            for (int i = base; i < base * 10; i++) {
                int x = i;
                for (int t = i / 10; t > 0; t /= 10) {
                    x = x * 10 + t % 10;
                }
                pal[palIdx++] = x;
            }
            // 生成偶数长度回文数
            if (base <= 1000) {
                for (int i = base; i < base * 10; i++) {
                    int x = i;
                    for (int t = i; t > 0; t /= 10) {
                        x = x * 10 + t % 10;
                    }
                    pal[palIdx++] = x;
                }
            }
        }
        pal[palIdx++] = 1_000_000_001;
    }

    public long minimumCost(int[] nums) {
        // 将数组中元素替换成某个数的最小代价是对应的中位数
        // 若数组元素为奇数，则正好是中位数
        // 若数组元素为偶数，则可以去两个中位数之间的任何值
        // 找离中位数最近的回文数

        int n = nums.length;
        int x = quickSelect(nums, (n - 1) / 2);
        int y = quickSelect(nums, n / 2);
        
        int i = lowerBound(x);
        long ans = cost(nums, i);

        if (pal[i] <= y) return ans;

        return Math.min(ans, cost(nums, i - 1));
    }

    // 返回 nums 中的所有数变成 pal[i] 的总代价
    private long cost(int[] nums, int i) {
        int target = pal[i];
        long sum = 0;
        for (int x : nums) {
            sum += Math.abs(x - target);
        }
        return sum;
    }

    void swap(int[] nums, int i, int j) {
        if (i == j) return;
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }

    int[] partition(int[] nums, int i, int j) {
        int idx = i + (int)((j - i) * Math.random());
        swap(nums, i, idx);
        int pivot = nums[i];
        int l = i, r = j, k = i;
        
        while (k <= r) {
            if (nums[k] < pivot) {
                swap(nums, l++, k++);
            } else if (nums[k] > pivot) {
                swap(nums, k, r--);
            } else {
                k++;
            }
        }
        return new int[]{l, r};
    }

    int quickSelect(int[] nums, int k) {
        int i = 0, j = nums.length - 1;
        while (i <= j) {
            int[] idxs = partition(nums, i, j);
            int l = idxs[0], r = idxs[1];
            if (k < l) {
                j = l - 1;
            } else if (r < k) {
                i = r + 1;
            } else {
                return nums[l];
            }
        }
        return -1;
    }


    // 寻找大于或等于给定元素的最小值
    int lowerBound(int val) {
        int l = 0, r = pal.length;
        while (l < r) {
            int mid = (l + r) >> 1;
            if (pal[mid] >= val) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        return l;
    }

    // 寻找小于等于给定元素的最大值
    int upperBound(int val) {
        int l = 0, r = pal.length;
        while (l < r) {
            int mid = (l + r) >> 1;
            if (pal[mid] <= val) {
                l = mid + 1;
            } else {
                r = mid;
            }
        }
        return l - 1;
    }
}
```