## 105. 从前序与中序遍历序列构造二叉树

给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。

 

示例 1:

![t1](./figs/tree%20(1).jpg)

>输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]  
>输出: [3,9,20,null,null,15,7]  


示例 2:

>输入: preorder = [-1], inorder = [-1]  
>输出: [-1]  
 

提示:

- 1 <= preorder.length <= 3000
- inorder.length == preorder.length
- -3000 <= preorder[i], inorder[i] <= 3000
- preorder 和 inorder 均 无重复 元素
- inorder 均出现在 preorder
- preorder 保证 为二叉树的前序遍历序列
- inorder 保证 为二叉树的中序遍历序列


## 题解

### 解法一、

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < inorder.length; i++) {
            map.put(inorder[i], i);
        }
        return createTree(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1, map);
    }

    public TreeNode createTree(int[] preorder, int pi, int pj, int[] inorder, int ii, int ij, Map<Integer, Integer> map) {
        if (pi > pj) return null;
        TreeNode root = new TreeNode(preorder[pi]);
        int mid = map.get(root.val);
        int left = pi + mid - ii;
        root.left = createTree(preorder, pi + 1, left, inorder, ii, mid - 1, map);
        root.right = createTree(preorder, left + 1, pj, inorder, mid + 1, ij, map);
        return root;
    }
}
```