## 100267. 单面值组合的第 K 小金额

给你一个整数数组 coins 表示不同面额的硬币，另给你一个整数 k 。

你有无限量的每种面额的硬币。但是，你 不能 组合使用不同面额的硬币。

返回使用这些硬币能制造的 第 kth 小 金额。

 

示例 1：

>输入： coins = [3,6,9], k = 3  
>  
>输出： 9  
>  
>解释：给定的硬币可以制造以下金额：  
>3元硬币产生3的倍数：3, 6, 9, 12, 15等。  
>6元硬币产生6的倍数：6, 12, 18, 24等。  
>9元硬币产生9的倍数：9, 18, 27, 36等。  
>所有硬币合起来可以产生：3, 6, 9, 12, 15等。  

示例 2：

>输入：coins = [5,2], k = 7  
>  
>输出：12  
>  
>解释：给定的硬币可以制造以下金额：  
>5元硬币产生5的倍数：5, 10, 15, 20等。  
>2元硬币产生2的倍数：2, 4, 6, 8, 10, 12等。  
>所有硬币合起来可以产生：2, 4, 5, 6, 8, 10, 12, 14, 15等。  

 

提示：

- 1 <= coins.length <= 15
- 1 <= coins[i] <= 25
- 1 <= k <= 2 * $10^9$
- coins 包含两两不同的整数。


## 题解

### 解法一、二分+容斥原理+枚举子集+最小公倍数

```java
class Solution {
    // 两个正数的最大公约数
    long gcd(long a, long b) {
        return b == 0? a: gcd(b, a % b);
    }

    // 两个正数的最小公倍数
    long lcm(long a, long b) {
        return a * b / gcd(a, b);
    }

    // 是否有k个小于或等于m的数？
    boolean check(int[] coins, long m, int k) {
        long cnt = 0;
        // 容斥原理：n个集合并集的大小等于 每个子集交集大小乘以(-1)^(子集大小-1)的和，即共2^n项
        // 枚举子集
        for (int i = 1; i < (1<<coins.length); i++) {
            long lcm_res = 1;
            for (int j = 0; j < coins.length; j++) {
                if ((i >> j & 1) == 1) {
                    lcm_res = lcm(lcm_res, coins[j]);
                }
            }
            long c = m / lcm_res;
            cnt += Integer.bitCount(i) % 2 == 1? c: -c;
        }
        return cnt >= k;
    }

    public long findKthSmallest(int[] coins, int k) {
        Arrays.sort(coins);
        long l = k - 1, r = (long)coins[0] * k;
        // 开区间二分
        while (l + 1 < r) {
            long mid = (l + r) >> 1;
            if (check(coins, mid, k)) {
                r = mid;
            } else {
                l = mid;
            }
        }
        return r;
    }
}
```
