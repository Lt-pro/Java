## 275. H 指数 II

给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被引用的次数，citations 已经按照 升序排列 。计算并返回该研究者的 h 指数。

h 指数的定义：h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （n 篇论文中）至少 有 h 篇论文分别被引用了至少 h 次。

请你设计并实现对数时间复杂度的算法解决此问题。

 

示例 1：

>输入：citations = [0,1,3,5,6]  
>输出：3  
>解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 0, 1, 3, 5, 6 次。  
>     由于研究者有3篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3 。  


示例 2：

>输入：citations = [1,2,100]  
>输出：2  
 

提示：

- n == citations.length
- 1 <= n <= 105
- 0 <= citations[i] <= 1000
- citations 按 升序排列

## 题解

### 解法一、二分查找

```java
class Solution {
    // 左闭右开写法
    public int hIndex(int[] citations) {
        int n = citations.length;
        int l = 1, r = n + 1;
        // 查找满足条件的最大h指数
        while (l < r) {
            // 循环不变量
            // l - 1的回答一定为是
            // r的回答一定是否
            int mid = (l + r) >> 1;
            // 是否有mid篇论文的引用次数不小于mid
            if (citations[n - mid] >= mid) {
                l = mid + 1;    // 询问范围缩小到 [mid + 1, r)
            } else {    
                r = mid;        // 询问范围缩小到 [l, mid)
            }
        }
        // 根据循环不变量，left - 1现在是最大的回答为是的数
        return l - 1;
    }
}
```

## 二分查找模板

### 左闭右开写法

```java
public class BinarySearch {

    // 从单调递增数组中查找取值为val的元素下标
    public static int binarySearch(int[] nums, int val) {
        int l = 0, r = nums.length;
        while (l < r) {
            // 循环不变量
            // l - 1为严格小于val的元素
            // r为严格大于val的元素
            int mid = (l + r) >> 1;
            if (nums[mid] == val) {
                return mid;
            } else if (nums[mid] < val) {
                l = mid + 1;
            } else {
                r = mid;
            }
        }
        return -1;
    }

    // 从单调递增数组中查找大于等于val的最小值下标，如果不存在返回-1；
    public static int lowerBound(int[] nums, int val) {
        int l = 0, r = nums.length;
        while (l < r) {
            // 循环不变量
            // l - 1为严格小于val的元素
            // r为大于或等于val的元素
            int mid = (l + r) >> 1;
            if (nums[mid] < val) {
                l = mid + 1;
            } else {
                r = mid;
            }
        }
        //依据循环不变量r是大于或等于val的最小值
        return r != nums.length? r: -1;
    }

    // 从单调递增数组中查找小于或等于val的最大值小标，如果不存在返回-1;
    public static int upperBound(int[] nums, int val) {
        int l = 0, r = nums.length;
        while (l < r) {
            // 循环不变量
            // l - 1为小于或等于val的元素
            // r为严格大于val的元素
            int mid = (l + r) >> 1;
            if (nums[mid] <= val) {
                l = mid + 1;
            } else {
                r = mid;
            }
        }
        // 一句循环不变量l - 1是小于或等于val的最大值
        return l - 1;
    }
}
```