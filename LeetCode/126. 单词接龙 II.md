## 126. 单词接龙 II


按字典 wordList 完成从单词 beginWord 到单词 endWord 转化，一个表示此过程的 转换序列 是形式上像 beginWord -> s1 -> s2 -> ... -> sk 这样的单词序列，并满足：

每对相邻的单词之间仅有单个字母不同。
转换过程中的每个单词 si（1 <= i <= k）必须是字典 wordList 中的单词。注意，beginWord 不必是字典 wordList 中的单词。
sk == endWord
给你两个单词 beginWord 和 endWord ，以及一个字典 wordList 。请你找出并返回所有从 beginWord 到 endWord 的 最短转换序列 ，如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表 [beginWord, s1, s2, ..., sk] 的形式返回。

 

示例 1：

>输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
>输出：\[["hit","hot","dot","dog","cog"],["hit","hot","lot","log","cog"]]
>解释：存在 2 种最短的转换序列：
>"hit" -> "hot" -> "dot" -> "dog" -> "cog"
>"hit" -> "hot" -> "lot" -> "log" -> "cog"


示例 2：

>输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
>输出：[]
>解释：endWord "cog" 不在字典 wordList 中，所以不存在符合要求的转换序列。
 

提示：

- 1 <= beginWord.length <= 5
- endWord.length == beginWord.length
- 1 <= wordList.length <= 500
- wordList[i].length == beginWord.length
- beginWord、endWord 和 wordList[i] 由小写英文字母组成
- beginWord != endWord
- wordList 中的所有单词 互不相同


## 题解

### 解法一、超时

```java
class Solution {

    private Set<String> dict = new HashSet<>();
    private List<List<String>> result = new ArrayList<>();
    private List<String> seq = new ArrayList<>();

    // BFS建树
    // DFS遍历得到最短路
    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {
        for (String word: wordList) dict.add(word);
        if (!dict.contains(endWord)) return result;
        Map<String, List<String>> tree = bfs(beginWord, endWord);
        seq.add(beginWord);
        dfs(tree, beginWord, endWord, null);
        return result;
    }

    List<String> getNeighbors(String word) {
        List<String> neighbors = new ArrayList<>();
        char[] s = word.toCharArray();
        for (int i = 0; i < word.length(); i++) {
            char tmp = s[i];
            for (char c = 'a'; c <= 'z'; c++) {
                if (c == tmp) continue;
                s[i] = c;
                String key = new String(s);
                if (dict.contains(key)) neighbors.add(key);
            }
            s[i] = tmp;
        }
        return neighbors;
    }

    // 记录从beginWord开始到endWord的最短路径
    // 若当前节点在以前的层中出现，则必不为最短路
    Map<String, List<String>> bfs(String beginWord, String endWord) {
        Map<String, List<String>> tree = new HashMap<>();
        Map<String, Integer> map = new HashMap<>();
        map.put(beginWord, 0);
        Queue<String> queue = new ArrayDeque<>();
        queue.offer(beginWord);
        int level = 0;
        boolean exists = false;

        while (!queue.isEmpty() && !exists) {
            level++;
            int currentLayer = queue.size();
            for (int i = 0; i < currentLayer; i++) {
                String node = queue.poll();
                if (node.equals(endWord)) {
                    exists = true;
                    continue;
                }
                List<String> neighbors = new ArrayList<>();
                for (String next: getNeighbors(node)) {
                    Integer h = map.get(next);
                    if (h == null || h == level) {
                        neighbors.add(next);
                        queue.offer(next);
                        map.put(next, level);
                    }
                }
                tree.put(node, neighbors);
            }
        }

        return tree;
    }

    void dfs(Map<String, List<String>> tree, String cur, String endWord, String pre) {
        if (cur.equals(endWord)) {
            result.add(new ArrayList<>(seq));
            return;
        }
        for (String next: tree.getOrDefault(cur, new ArrayList<String>())) {
            if (!next.equals(pre)) {
                seq.add(next);
                dfs(tree, next, endWord, cur);
                seq.remove(seq.size() - 1);
            }
        }
    }
}

```

### 解法二、双向搜索

```java
class Solution {
    private List<List<String>> result = new ArrayList<>();
    private Deque<String> seq = new ArrayDeque<>();

    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {
        Map<String, List<String>> rTree = bfs(beginWord, endWord, wordList);
        seq.offerFirst(endWord);
        dfs(rTree, endWord, beginWord, null);
        return result;
    }

    // 从开始节点搜索末尾节点的最短树
    Map<String, List<String>> bfs(String beginWord, String endWord, List<String> wordList) {
        Map<String, Integer> map = new HashMap<>();
        map.put(beginWord, 0);
        // 从末尾节点到开始节点的反向最短树
        Map<String, List<String>> rTree = new HashMap<>();
        Set<String> dict = new HashSet<>(wordList);
        Queue<String> queue = new ArrayDeque<>();
        queue.offer(beginWord);
        int level = 0;
        boolean found = false;

        while (!queue.isEmpty() && !found) {
            level++;
            int currentLayer = queue.size();
            for (int i = 0; i < currentLayer; i++) {
                String word = queue.poll();
                char[] s = word.toCharArray();
                // 枚举每个位置的字符比搜索整个字典效率要高
                for (int j = 0; j < word.length(); j++) {
                    char tmp = s[j];
                    for (char c = 'a'; c <= 'z'; c++) {
                        if (c == tmp) continue;
                        s[j] = c;
                        String next = new String(s);

                        // 当next至少第二次出现在下一层时，记录该边
                        if (map.containsKey(next) && level == map.get(next)) {
                            rTree.get(next).add(word);
                        }

                        if (!dict.contains(next)) continue;
                        // 防止以前层的节点在下一层出现，但允许同一结点在下一层出现多次
                        dict.remove(next);

                        rTree.put(next, new ArrayList<String>());
                        rTree.get(next).add(word);
                        map.put(next, level);
                        queue.offer(next);

                        if (next.equals(endWord)) found = true;
                    }
                    s[j] = tmp;
                }
            }
        }

        return rTree;
    }

    // 从尾节点开始反向搜索
    void dfs(Map<String, List<String>> rTree, String cur, String beginWord, String pre) {
        if (cur.equals(beginWord)) {
            result.add(new ArrayList<>(seq));
            return;
        }

        for (String next: rTree.getOrDefault(cur, new ArrayList<String>())) {
            if (!next.equals(pre)) {
                seq.offerFirst(next);
                dfs(rTree, next, beginWord, cur);
                seq.pollFirst();
            }
        }
    }
}
```