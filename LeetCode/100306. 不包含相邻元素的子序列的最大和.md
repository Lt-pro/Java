## 100306. 不包含相邻元素的子序列的最大和

给你一个整数数组 nums 和一个二维数组 queries，其中 queries[i] = [posi, xi]。

对于每个查询 i，首先将 nums[posi] 设置为 xi，然后计算查询 i 的答案，该答案为 nums 中 不包含相邻元素 的子序列的 最大 和。

返回所有查询的答案之和。

由于最终答案可能非常大，返回其对 109 + 7 取余 的结果。

子序列 是指从另一个数组中删除一些或不删除元素而不改变剩余元素顺序得到的数组。

 

示例 1：

>输入：nums = [3,5,9], queries = \[[1,-2],[0,-3]]  
>  
>输出：21  
>  
>解释：  
>执行第 1 个查询后，nums = [3,-2,9]，不包含相邻元素的子序列的最大和为 3 + 9 = 12。  
>执行第 2 个查询后，nums = [-3,-2,9]，不包含相邻元素的子序列的最大和为 9 。  

示例 2：

>输入：nums = [0,-1], queries = \[[0,-5]]  
>  
>输出：0  
>  
>解释：  
>执行第 1 个查询后，nums = [-5,-1]，不包含相邻元素的子序列的最大和为 0（选择空子序列）。  

 

提示：

- 1 <= nums.length <= 5 * $10^4$
- -$10^5$ <= nums[i] <= $10^5$
- 1 <= queries.length <= 5 * $10^4$
- queries[i] == [posi, xi]
- 0 <= posi <= nums.length - 1
- -$10^5$ <= xi <= $10^5$


## 题解

### 解法一、线段树

```java
class Solution {
    public static final long M = 1_000_000_007L;
    
    public int maximumSumSubsequence(int[] nums, int[][] queries) {
        long ans = 0L;
        SegmentTree tree = new SegmentTree(nums);
        for (int[] query: queries) {
            tree.update(query[0], query[1]);
            ans = (ans + tree.query()) % M;
        }
        return (int)ans;
    }

    static class SegmentTree {
        // tree[i][0]: (l, r)既不包含l,也不包含r的子序列最大和
        // tree[i][1]: (l, r]不包含l, 可能包含r的子序列最大和
        // tree[i][2]: [l, r)可能包含l, 不包含r的子序列最大和
        // tree[i][3]: [l, r]可能包含l, 也可能包含r的子序列最大和
        private long[][] tree;
        private int[] nums;
        private int n;

        public SegmentTree(int[] nums) {
            this.n = nums.length;
            this.tree = new long[n * 4][4];
            this.nums = nums;
            this.build(0, 0, n - 1);
        }

        private void build(int node, int l, int r) {
            if (l == r) {
                tree[node] = new long[]{0L, 0L, 0L, Math.max(0L, (long)nums[l])};
                return;
            }
            int mid = (l + r) >> 1;
            int leftChild = node * 2 + 1;
            int rightChild = node * 2 + 2;
            build(leftChild, l, mid);
            build(rightChild, mid + 1, r);
            tree[node] = merge(tree[leftChild], tree[rightChild]);
        }

        private long[] merge(long[] left, long[] right) {
            long[] root = new long[4];
            root[0] = Math.max(left[0] + right[2], left[1] + right[0]);
            root[1] = Math.max(left[0] + right[3], left[1] + right[1]);
            root[2] = Math.max(left[2] + right[2], left[3] + right[0]);
            root[3] = Math.max(left[2] + right[3], left[3] + right[1]);
            return root;
        }

        public void update(int pos, long val) {
            update(0, 0, n - 1, pos, val);
        }

        public void update(int node, int l, int r, int pos, long val) {
            if (l == r) {
                tree[node] = new long[]{0L, 0L, 0L, Math.max(0L, val)};
                return;
            }
            int mid = (l + r) >> 1;
            int leftChild = node * 2 + 1;
            int rightChild = node * 2 + 2;
            if (pos <= mid) {
                update(leftChild, l, mid, pos, val);
            } else {
                update(rightChild, mid + 1, r, pos, val);
            } 
            tree[node] = merge(tree[leftChild], tree[rightChild]);
        }

        public long query() {
            return tree[0][3];
        }
    }
}
```


## 相关问题

- [53. 最大子数组和](./53.%20最大子数组和.md)
- [100306. 不包含相邻元素的子序列的最大和](./100306.%20不包含相邻元素的子序列的最大和.md)