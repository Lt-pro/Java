## 215. 数组中的第K个最大元素

给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。

请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。

 

示例 1:

>输入: [3,2,1,5,6,4], k = 2  
>输出: 5  

示例 2:

>输入: [3,2,3,1,2,4,5,5,6], k = 4  
>输出: 4  
 

提示：

- 1 <= k <= nums.length <= $10^5$
- -$10^4$ <= nums[i] <= $10^4$

## 题解

### 解法一、小顶堆

```java
class Solution {

    public int findKthLargest(int[] nums, int k) {
        MinHeap heap = new MinHeap(k + 1);
        for (int val: nums) {
            heap.push(val);
            // 当小顶堆元素大于k时，淘汰一个最小的元素
            if (heap.size() > k) heap.pop();
            // heap.print();
        }
        return heap.top();
    }

    static class MinHeap {
        private int[] heap;
        private int n;

        public void print() {
            for (int i = 0; i < n; i++) {
                System.out.print(heap[i] + "\t");
            }
            System.out.println();
        }

        public MinHeap(int k) throws IllegalArgumentException{
            if (k <= 0) throw new IllegalArgumentException();
            heap = new int[k];
        }

        public void push(int val) throws ArrayIndexOutOfBoundsException{
            if (n >= heap.length) throw new ArrayIndexOutOfBoundsException();
            heap[n++] = val;
            heapifyUp();
        }

        public int pop() throws ArrayIndexOutOfBoundsException{
            if (n <= 0) throw new ArrayIndexOutOfBoundsException();
            int val = heap[0];
            heap[0] = heap[--n];
            heapifyDown();
            return val;
        }

        public int top() throws ArrayIndexOutOfBoundsException{
            if (n <= 0) throw new ArrayIndexOutOfBoundsException();
            return heap[0];
        }

        public boolean isEmpty() {
            return n != 0;
        }

        public int size() {
            return n;
        }

        // 自底而上堆化，调整堆尾元素
        private void heapifyUp() {
            int child = n - 1;
            int pivot = heap[child];
            // 如果有双亲，则继续
            while (child > 0) {
                int parent = (child - 1) >> 1;
                // 如果以满足小顶堆条件，终止
                if (heap[parent] <= pivot) break;
                heap[child] = heap[parent];
                child = parent;
            }
            // 连续交换后归位元素
            heap[child] = pivot;
        }

        // 自顶而下堆化，调整堆顶元素
        private void heapifyDown() {
            int parent = 0;
            int pivot = heap[0];
            int child = -1;
            // 如果至少存在一个左孩子，继续比较
            while ((child = (parent << 1) + 1) < n) {
                // 如果存在右孩子且数值小于于左孩子，取右孩子
                if (child + 1 < n && heap[child + 1] < heap[child]) {
                    child++;
                }
                // 如果满足小顶堆条件，终止
                if (pivot <= heap[child]) break;
                heap[parent] = heap[child];
                parent = child;
            }
            // 连续交换后归位元素
            heap[parent] = pivot;
        }
    }
}
```

### 解法二、快选

