## 1901. 寻找峰值 II

一个 2D 网格中的 峰值 是指那些 严格大于 其相邻格子(上、下、左、右)的元素。

给你一个 从 0 开始编号 的 m x n 矩阵 mat ，其中任意两个相邻格子的值都 不相同 。找出 任意一个 峰值 mat[i][j] 并 返回其位置 [i,j] 。

你可以假设整个矩阵周边环绕着一圈值为 -1 的格子。

要求必须写出时间复杂度为 O(m log(n)) 或 O(n log(m)) 的算法

 

 

示例 1:

![图一](./figs/1.png)

>输入: mat = \[[1,4],[3,2]]
>输出: [0,1]
>解释: 3 和 4 都是峰值，所以[1,0]和[0,1]都是可接受的答案。


示例 2:

![图二](./figs/3.png)

>输入: mat = \[[10,20,15],[21,30,14],[7,16,32]]
>输出: [1,1]
>解释: 30 和 32 都是峰值，所以[1,1]和[2,2]都是可接受的答案。
 

提示：

- m == mat.length
- n == mat[i].length
- 1 <= m, n <= 500
- 1 <= mat[i][j] <= $10^5$
- 任意两个相邻元素均不相等.

## 题解

### 解法一、二分

```java
class Solution {
    // 以行为例说明
    // 考虑第i行的最大元素，其必严格大于左右两边相邻元素，若其大于上下相邻元素则为峰值
    // 存在性证明：
    // 假设没有满足上述条件的元素为峰值，考虑第0行最大元素mat[0][j_0]，其一定大于-1.
    // 假设第i行最大元素为mat[i][j_i]，若其不为峰值，可以有mat[i][j_i] < mat[i+1][j_i]，
    // 令第i+1行最大值为mat[i+1][j_(i+1)]，则mat[i+1][j_(i+1)]>=mat[i+1][j_i] > mat[i][j_i] >= mat[i][j]
    // 即mat[i+1][j_(i+1)] > mat[i][j]
    // 将该关系递推到第m-1行，有mat[m - 1][j_(m-1)]，由于下一行全部为-1，反设不成立
    // 二分方法
    // 对于每一行的最大值，如果小于下一列相邻值，则峰值在上边，否则在下边
    public int[] findPeakGrid(int[][] mat) {
        int m = mat.length, n = mat[0].length;
        // 二分行
        // [top, bottom]为包含峰值的区间，当至少有两个行时继续划分，剩余一个行时其中的最大值就是所求峰值
        int top = 0, bottom = m - 1;
        while (top < bottom) {
            int i = (top + bottom) >> 1;
            int j = max(mat[i]);
            if (mat[i][j] > mat[i + 1][j]) {
                bottom = i;
            } else {
                top = i + 1;
            }
        }
        return new int[]{top, max(mat[top])};
    }

    int max(int[] nums) {
        int j = 0, val = Integer.MIN_VALUE;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] > val) {
                j = i;
                val = nums[i];
            }
        }
        return j;
    }
}
```

## 相关问题

- [162寻找峰值](./162寻找峰值.md)
- [1901寻找峰值](./1901寻找峰值Ⅱ.md)
