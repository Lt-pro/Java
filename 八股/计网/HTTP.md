# HTTP

## HTTP是什么？

### HTTP是什么？

HTTP(Hyper Text Transfer Protocol)全称是超文本传输协议，它是网络中客户端与服务端传输**文本、图像、语音、视频以及各种类型数据**的双向传输协议。

- 协议：HTTP 是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（两个以上的参与者），以及相关的各种控制和错误处理方式（行为约定和规范）。
- 传输：它是一个双向协议，但允许有中转。
- 超文本：它就是超越了普通文本的文本，它是文字、图片、视频等的混合体。

### HTTP通信过程？

HTTP协议基于请求——响应模式进行超文本传输，客户端发起请求时需指定请求路径URL、请求方式、请求参数，协议将其封装成请求报文发送出去。服务端接受请求后会进行处理并返回一个响应报文，响应报文包含状态码、响应体和其它字段，其中状态码表明响应结果，响应体包含请求希望获取的信息，其它字段用于控制等。

单纯的HTTP是一个无状态协议，每一对请求——响应都是相互独立的。


### HTTP的状态码？

![HTTP状态码](./figs/6-五大类HTTP状态码.webp)


1xx 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。

2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。

- 「200 OK」是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。
- 「204 No Content」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。
- 「206 Partial Content」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。

3xx 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。

- 「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。
- 「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。
- 「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。

4xx 类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。

- 「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。
- 「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。
- 「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。

5xx 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。

- 「500 Internal Server Error」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。
- 「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。
- 「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
- 「503 Service Unavailable」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。


### HTTP常见字段？

- Host 字段: 客户端发送请求时，用来指定服务器的域名。
- Content-Length: 服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据长度。
  大家应该都知道 HTTP 是基于 TCP 传输协议进行通信的，而使用了 TCP 传输协议，就会存在一个“粘包”的问题，HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题。
- Connection: Connection字段最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用。
  HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。
- Content-Type: Content-Type 字段用于服务器回应时，告诉客户端，本次数据是什么格式。
- Accept: 客户端请求的时候，可以使用 Accept 字段声明自己可以接受哪些数据格式。
- Content-Encoding: 说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式。
- Accept-Encoding: 客户端在请求时，用 Accept-Encoding 字段说明自己可以接受哪些压缩方法。


### GET与POST请求？

GET请求

- GET请求的语义是从服务器获取指定的资源，资源可以是文本、图像、语音、视频等。
- GET请求的请求参数只能ASCII字符。
- 浏览器一般会对URL的大小有一定限制。


POST请求

- POST请求语义是根据负荷对服务器的资源做处理，这个处理是任意的。但一般POST请求用于新增数据。
- POST请求参数一般放在请求体中。
- 浏览器不会对请求体大小有任何限制。


### GET与POST的幂等性与安全性？

如果从 RFC 规范定义的语义来看：

- GET 方法就是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，可以对 GET 请求的数据做缓   存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签。
- POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。所以，浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签。


从数据安全性角度看：

GET和POST都不是安全的，因为在HTTP1中数据通过明文传输，无法确认数据是否被窃取、篡改、也无法进行身份和权限验证。



## HTTP的缓存策略

HTTP的缓存策略分为强制缓存和协商缓存：

- 强制缓存的思想是由浏览器决定是否使用缓存资源，当浏览器认为缓存资源过期后就会像服务器重新请求资源。
- 协商缓存的思想是由浏览器和服务器共同决定是否使用缓存资源，当浏览器认为资源过期后会向服务器重新请求资源，服务器会根据资源是否被修改决定是返回新的资源还是重定向到浏览器缓存。


### 强制缓存实现

强制缓存依赖Cache-Control和Expire两个字段实现，Cache-Control表示相对过期时间，Expire表示绝对过期时间，一般Cache-Control优先级更高。

- 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；
- 浏览器再次请求访问服务器中的该资源时，会先通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期，如果没有，则使用该缓存，否则重新请求服务器；
- 服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。


### 协商缓存实现

协商缓存有两种实现方式，第一种依赖于If-Modified-Since和Last-Modified字段，利用时间戳作为标识；第二种依赖于If-None-Match和ETag字段，利用唯一id作为标识。


- 当浏览器第一次向服务器发起请求时，服务器接收响应并返回一个报文，在响应头中加入Last-Modified信息。
- 当浏览器判断资源过期时会在请求中将Last-Modified的信息填入If-Modified-Since，若请求中的If-Modified-Since时间大于或等于服务器中存储的Last-Modified，则重定向到浏览器缓存，否则返回一个新的资源。


ETag的实现方式类似，只是ETag更加稳定, 优先级更高。

注意，协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求。


![http缓存](./figs/http缓存.webp)



## HTTP1.1

### HTTP1.1的优缺点？

优点：

- 简单：报文是简单的header+body形式，header以key-value的文本形式存在，易于理解。
- 灵活且易扩展：请求方式、URI/URL、状态码和请求头都可以自定义扩充；HTTP的应用层以下的协议也可以自定义。
- 应用广泛：网页、客户端、小程序都可以。

缺点：

- 无状态：每一对请求——响应相互独立，无法处理如“登录——添加购物车——下单——支付——结算”这样具有依赖的功能。
- 明文传输：HTTP报文的header+body全部是明文传输，无法防止信息被窃取、篡改以及身份验证问题。

### HTTP1.0的请求——响应模式？

HTTP1.0为**每一个请求建立一个连接并且请求按照串行方式进行传输**，HTTP请求会经历连接建立、请求、响应、连接断开、连接建立、...这样的循环往复。

**队头阻塞**: 在串行传输时，如果一个请求一直在等待响应会导致后面的响应无法发送出去。


### HTTP1.1的解决方案？

- 长连接：HTTP1.1允许设置长连接，即请求——响应完成后如果通信双方不主动断开连接则一直保持存在，这样可以避免请求——响应之间频繁建立与断开连接造成的资源与时间开销。当双方长时间没有数据传输时，服务器也会主动断开连接。
- 管道化：管道化允许当前请求发送后不必等待返回响应就发送下一个请求，它解决了客户端的队头阻塞问题，但没有解决服务端的队头阻塞问题。注意管道化技术并未被大多浏览器设为默认支持。
























